#!/usr/bin/env bash 
set -e


need() {
	if ! command -v "$1" >/dev/null 2>&1; then
		echo "Isn't found: $1"
		echo "Installing $1 ..."

	  #визначаємо систему та встановлюємо потрібне
	  if command -v apt-get >/dev/null 2>&1; then
	        sudo apt-get update -y
	        
			case "$1" in
			    arm-none-eabi-gcc)
			        sudo apt-get install -y gcc-arm-none-eabi binutils-arm-none-eabi
			        ;;
			    ninja)
			        sudo apt-get install -y ninja-build
			        ;;
			    st-flash)
			        sudo apt-get install -y stlink-tools
			        ;;
			    openocd)
			        sudo apt-get install -y openocd
			        ;;
			    *)
			        sudo apt-get install -y "$1"
			        ;;
			esac


		elif command -v brew >/dev/null 2>&1; then
			brew install "$1"
		elif command -v pacman >/dev/null 2>&1; then
			sudo pacman -Sy --noconfirm "$1"
		else 
			echo "There are no needed package manager. Instlall '$1' by yourself"
			exit 1
		fi 


		command -v "$1" >/dev/null 2>&1 || {
			echo "failed to install '$1'"
			exit 1
		}
		
		echo -e "\033[1;32m✅ Successfully installed: $1\033[0m"
	fi	
 }


echo "Searching tools..."
need arm-none-eabi-gcc
need arm-none-eabi-objcopy
need cmake
need ninja
echo "Everything  is founded"


#==================================================================================

# === Конфігурація проекта ===
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" #визначення положення рут файла
BUILD_DIR="${BUILD_DIR:-$PROJECT_ROOT/build}" #положення build-файла
GEN="${GEN:-Ninja}"         
MCU="${MCU:-STM32F411xE}"            # define для компіляції
TOOLCHAIN_FILE="${TOOLCHAIN_FILE:-$PROJECT_ROOT/cmake/toolchain-arm-none-eabi.cmake}"
LINKER_SCRIPT="${LINKER_SCRIPT:-$PROJECT_ROOT/linker/STM32F411CEUx_FLASH.ld}"
TARGET_NAME="${TARGET_NAME:-firmware}"  # ім"я elf-файла, який створює СMake



configure() {
	echo "Project configuration"
	mkdir -p "$BUILD_DIR"

	cmake -S "$PROJECT_ROOT" -B "$BUILD_DIR" \
		  -G "$GEN" \
		  -DCMAKE_TOOLCHAIN_FILE="$TOOLCHAIN_FILE" \
		  -DMCU_DEFINE="$MCU" \
		  -DLINKER_SCRIPT="$LINKER_SCRIPT"

	echo -e "\033[1;32m Cmake configuration is done!!!!\033[0m"
}


init_toolchain() {
	local TOOLCHAIN_PATH="$PROJECT_ROOT/cmake/toolchain-arm-none-eabi.cmake"

	if [[ -f "$TOOLCHAIN_PATH" ]]; then
		echo "Toolchain already exists"
		return
	fi

	echo "Creating toolchain-file..."
	mkdir -p "$PROJECT_ROOT/cmake"

	cat > "$TOOLCHAIN_PATH" << 'EOF'

# ==== Auto-generated toolchain file ====
set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_SYSTEM_PROCESSOR arm)


set(CMAKE_C_COMPILER 	arm-none-eabi-gcc)
set(CMAKE_ASM_COMPILER  arm-none-eabi-gcc)
set(CMAKE_AR 			arm-none-eabi-ar)
set(CMAKE_OBJCOPY		arm-none-eabi-objcopy)
set(CMAKE_SIZE			arm-none-eabi-size)

set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)
EOF

	echo "Toolchain is created: $TOOLCHAIN_PATH"

}


init_linker(){
	local LINKER_PATH="$PROJECT_ROOT/linker/STM32F411CEUx_FLASH.ld"

	if [[ -f "$LINKER_PATH" ]]; then 
		echo "Linker script already exists"
		return 
	fi

	echo "Creating linker script"
	mkdir -p "$PROJECT_ROOT/linker"

	cat > "$LINKER_PATH" << 'EOF'

ENTRY(Reset_Handler)

MEMORY
{
  FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 512K
  RAM   (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
}

_estack = ORIGIN(RAM) + LENGTH(RAM);

SECTIONS
{

  .isr_vector :
  {
    KEEP(*(.isr_vector)) 
  } > FLASH


  .text :
  {
    *(.text*)               /* код */
    *(.rodata*)             /* константы */
    KEEP(*(.init))
    KEEP(*(.fini))
  } > FLASH


  .ARM.exidx : { *(.ARM.exidx*) } > FLASH


  .data : AT (ADDR(.text) + SIZEOF(.text))
  {
    _sdata = .;
    *(.data*)
    _edata = .;
  } > RAM

  .bss (NOLOAD) :
  {
    _sbss = .;
    *(.bss*) *(COMMON)
    _ebss = .;
  } > RAM

  ._user_heap_stack (NOLOAD) :
  {
    . = ALIGN(8);
    _sheap = .;
    . = . + 0x1000;   /* heap = 4 KB */
    . = ALIGN(8);
    _eheap = .;

    . = ALIGN(8);
    _sstack = .;
    . = . + 0x1000;   /* stack = 4 KB */
    . = ALIGN(8);
    _estack_dummy = .;
  } > RAM
}
EOF

    echo "Linker script is created: $LINKER_PATH"
}


init_startup() {
    local STARTUP_PATH="$PROJECT_ROOT/startup/startup_stm32f411xe.s"


    if [[ -f "$STARTUP_PATH" ]]; then
        echo "✅ Startup already exists"
        return
    fi

    echo "Creating startup-file..."
    mkdir -p "$PROJECT_ROOT/startup"

    cat > "$STARTUP_PATH" << 'EOF'

.syntax unified
.cpu cortex-m4
.fpu fpv4-sp-d16
.thumb

.word _estack
.word Reset_Handler

.section .isr_vector, "a", %progbits
g_pfnVectors:
  .word _estack    
  .word Reset_Handler
  .word NMI_Handler
  .word HardFault_Handler
  .word Default_Handler
  .word Default_Handler
  .word Default_Handler
  .word Default_Handler
  .word Default_Handler
  .word Default_Handler
  .word Default_Handler

.section .text.Reset_Handler
.thumb_func
Reset_Handler:
  ldr r0, =_sdata
  ldr r1, =_edata
  ldr r2, =_sidata
1: cmp r0, r1
   ittt lt
   ldrlt r3, [r2], #4
   strlt r3, [r0], #4
   blt 1b

  ldr r0, =_sbss
  ldr r1, =_ebss
  movs r2, #0
2: cmp r0, r1
   itt lt
   strlt r2, [r0], #4
   blt 2b

  bl main

  b .

.size Reset_Handler, .-Reset_Handler

.thumb_func
Default_Handler:
  b .

.thumb_func
NMI_Handler:
  b .

.thumb_func
HardFault_Handler:
  b .
EOF

    echo "Startup is created: $STARTUP_PATH"
}


init_system() {
    local SYS_H="$PROJECT_ROOT/include/system_stm32f4xx.h"
    local SYS_C="$PROJECT_ROOT/src/system_stm32f4xx.c"

    # если уже есть — не пересоздаём
    if [[ -f "$SYS_H" && -f "$SYS_C" ]]; then
        echo "✅ SystemInit already exists"
        return
    fi

    echo "Creating system-file..."
    mkdir -p "$PROJECT_ROOT/include" "$PROJECT_ROOT/src"

    # --- system_stm32f4xx.h ---
    cat > "$SYS_H" << 'EOF'
#ifndef SYSTEM_STM32F4XX_H
#define SYSTEM_STM32F4XX_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

extern uint32_t SystemCoreClock;

void SystemInit(void);
void SystemCoreClockUpdate(void);

#ifdef __cplusplus
}
#endif

#endif /* SYSTEM_STM32F4XX_H */
EOF

    # --- system_stm32f4xx.c ---
    cat > "$SYS_C" << 'EOF'
#include "system_stm32f4xx.h"
#include "stm32f4xx.h"

uint32_t SystemCoreClock = 16000000U;

void SystemInit(void) {
    RCC->CR |= RCC_CR_HSION;
    while (!(RCC->CR & RCC_CR_HSIRDY)) {}

    RCC->CFGR = 0x00000000;
    RCC->PLLCFGR = 0x24003010;
    RCC->CR &= ~(RCC_CR_PLLON);
    RCC->CIR = 0x00000000;

    SCB->ICSR = 0;
}

void SystemCoreClockUpdate(void) {
    SystemCoreClock = 16000000U;
}
EOF

    echo "System-files are created: $SYS_H и $SYS_C"
}



init_main() {
    local MAIN_C="$PROJECT_ROOT/src/main.c"

    if [[ -f "$MAIN_C" ]]; then
        echo "main.c already exists"
        return
    fi

    echo "Creating main.c..."
    mkdir -p "$PROJECT_ROOT/src"

    cat > "$MAIN_C" << 'EOF'
#include "system_stm32f4xx.h"

int main(void) {
    SystemInit();

    while (1) {
        __asm__("nop");
    }

    return 0;
}
EOF

    echo "main.c is created: $MAIN_C"
}


init_cmake() {
    local CMAKE_PATH="$PROJECT_ROOT/CMakeLists.txt"

    if [[ -f "$CMAKE_PATH" ]]; then
        echo "CMakeLists.txt already exists"
        return
    fi

    echo "Сreating CMakeLists.txt..."
    cat > "$CMAKE_PATH" << 'EOF'

cmake_minimum_required(VERSION 3.20)
project(firmware C ASM)

set(CMAKE_TOOLCHAIN_FILE \${CMAKE_SOURCE_DIR}/cmake/toolchain-arm-none-eabi.cmake)

add_compile_definitions(
  STM32F411xE
  USE_HAL_DRIVER=0
)

set(CPU_FLAGS "-mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard")
set(COMMON_FLAGS "-ffunction-sections -fdata-sections -Wall -Wextra -Werror -fno-common")
set(LINK_FLAGS "-Wl,--gc-sections -T\${CMAKE_SOURCE_DIR}/linker/STM32F411CEUx_FLASH.ld")

add_compile_options(\${CPU_FLAGS} \${COMMON_FLAGS})
add_link_options(\${CPU_FLAGS} \${LINK_FLAGS})

include_directories(
  include
)

set(SRC
    src/main.c
    src/system_stm32f4xx.c
    startup/startup_stm32f411xe.s
)

add_executable(\${PROJECT_NAME}.elf \${SRC})

add_custom_command(TARGET \${PROJECT_NAME}.elf POST_BUILD
    COMMAND \${CMAKE_OBJCOPY} -O binary \${PROJECT_NAME}.elf \${PROJECT_NAME}.bin
    COMMAND \${CMAKE_SIZE} \${PROJECT_NAME}.elf
)
EOF

    echo "CMakeLists.txt is created: $CMAKE_PATH"
}


echo "Generating STM32 project structure..."
init_toolchain
init_linker
init_startup
init_system
init_main
init_cmake
echo -e "\033[1;32m Project structure created.\033[0m"

echo " Configuring CMake..."
mkdir -p "$BUILD_DIR"
cmake -S "$PROJECT_ROOT" -B "$BUILD_DIR" -G "$GEN" \
      -DCMAKE_TOOLCHAIN_FILE="$TOOLCHAIN_FILE" \
      -DMCU_DEFINE="$MCU" \
      -DLINKER_SCRIPT="$LINKER_SCRIPT"

echo "Building..."
cmake --build "$BUILD_DIR"

echo -e "\033[1;32m Build finished! Firmware ready in: $BUILD_DIR/firmware.bin\033[0m"


# ACHTUNG: 
# mkdir -p include
# wget https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f4xx.h -O include/stm32f4xx.h